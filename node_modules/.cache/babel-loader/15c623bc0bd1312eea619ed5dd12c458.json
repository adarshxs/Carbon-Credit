{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"C:/Users/adars/OneDrive/Desktop/defi_yield_farming-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/adars/OneDrive/Desktop/defi_yield_farming-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nvar logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  var errors = [];\n\n  var checkErrors = function checkErrors(path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n\n    for (var key in object) {\n      var childPath = path.slice();\n      childPath.push(key);\n\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n\n  checkErrors([], result);\n  return errors;\n}\nexport var Coder = /*#__PURE__*/function () {\n  function Coder(name, type, localName, dynamic) {\n    _classCallCheck(this, Coder);\n\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message, value) {\n      logger.throwArgumentError(message, this.localName, value);\n    }\n  }]);\n\n  return Coder;\n}();\nexport var Writer = /*#__PURE__*/function () {\n  function Writer(wordSize) {\n    _classCallCheck(this, Writer);\n\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = arrayify([]);\n    this._padding = new Uint8Array(wordSize);\n  }\n\n  _createClass(Writer, [{\n    key: \"_writeData\",\n    value: function _writeData(data) {\n      this._data = concat([this._data, data]);\n      return data.length;\n    } // Arrayish items; padded on the right to wordSize\n\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(value) {\n      var bytes = arrayify(value);\n\n      if (bytes.length % this.wordSize) {\n        bytes = concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n      }\n\n      return this._writeData(bytes);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(value) {\n      var bytes = arrayify(BigNumber.from(value));\n\n      if (bytes.length > this.wordSize) {\n        logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this.wordSize,\n          offset: bytes.length\n        });\n      }\n\n      if (bytes.length % this.wordSize) {\n        bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n      }\n\n      return bytes;\n    } // BigNumberish items; padded on the left to wordSize\n\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      return this._writeData(this._getValue(value));\n    }\n  }, {\n    key: \"writeUpdatableValue\",\n    value: function writeUpdatableValue() {\n      var _this = this;\n\n      var offset = this.length;\n      this.writeValue(0);\n      return function (value) {\n        _this._data.set(_this._getValue(value), offset);\n      };\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return hexlify(this._data);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._data.length;\n    }\n  }]);\n\n  return Writer;\n}();\nexport var Reader = /*#__PURE__*/function () {\n  function Reader(data, wordSize, coerceFunc) {\n    _classCallCheck(this, Reader);\n\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    this._offset = 0;\n  }\n\n  _createClass(Reader, [{\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      if (this._coerceFunc) {\n        return this._coerceFunc(name, value);\n      }\n\n      return Reader.coerce(name, value);\n    }\n  }, {\n    key: \"_peekBytes\",\n    value: function _peekBytes(offset, length) {\n      var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\n      if (this._offset + alignedLength > this._data.length) {\n        logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this._data.length,\n          offset: this._offset + alignedLength\n        });\n      }\n\n      return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n  }, {\n    key: \"subReader\",\n    value: function subReader(offset) {\n      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n    }\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(length) {\n      var bytes = this._peekBytes(0, length);\n\n      this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?\n\n      return bytes.slice(0, length);\n    }\n  }, {\n    key: \"readValue\",\n    value: function readValue() {\n      return BigNumber.from(this.readBytes(this.wordSize));\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return hexlify(this._data);\n    }\n  }, {\n    key: \"consumed\",\n    get: function get() {\n      return this._offset;\n    } // The default Coerce function\n\n  }], [{\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      var match = name.match(\"^u?int([0-9]+)$\");\n\n      if (match && parseInt(match[1]) <= 48) {\n        value = value.toNumber();\n      }\n\n      return value;\n    }\n  }]);\n\n  return Reader;\n}();","map":{"version":3,"sources":["C:/Users/adars/OneDrive/Desktop/defi_yield_farming-main/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"],"names":["arrayify","concat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","checkResultErrors","result","errors","checkErrors","path","object","Array","isArray","key","childPath","slice","push","error","Coder","name","type","localName","dynamic","message","value","throwArgumentError","Writer","wordSize","_data","_padding","Uint8Array","data","length","bytes","_writeData","from","throwError","BUFFER_OVERRUN","offset","_getValue","writeValue","set","Reader","coerceFunc","_offset","_coerceFunc","coerce","alignedLength","Math","ceil","_peekBytes","readBytes","match","parseInt","toNumber"],"mappings":"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","sourcesContent":["\"use strict\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = arrayify([]);\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() { return hexlify(this._data); }\n    get length() { return this._data.length; }\n    _writeData(data) {\n        this._data = concat([this._data, data]);\n        return data.length;\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        if (bytes.length % this.wordSize) {\n            bytes = concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        let offset = this.length;\n        this.writeValue(0);\n        return (value) => {\n            this._data.set(this._getValue(value), offset);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this._data.length,\n                offset: this._offset + alignedLength\n            });\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n    }\n    readBytes(length) {\n        let bytes = this._peekBytes(0, length);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}